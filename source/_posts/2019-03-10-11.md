
title: åŸºäºNettyçš„RPCæ¶æ„å­¦ä¹ ç¬”è®°ï¼ˆåä¸€ï¼‰ï¼šç²˜åŒ…ã€åˆ†åŒ…åˆ†æï¼Œå¦‚ä½•é¿å…socketæ”»å‡»
author: Leesin.Dong
top: 
tags:
  - Netty
categories:
  - å­¦ä¹ ç¬”è®°
  - åŸºäºNettyçš„RPCæ¶æ„å­¦ä¹ ç¬”è®°
date: 2019-3-10 10:21:11

---

# é—®é¢˜
## æ¶ˆæ¯å¦‚ä½•åœ¨ç®¡é“ä¸­æµè½¬
å½“å‰çš„ä¸€ä¸ªhandlerå¦‚ä½•å¾€ä¸‹é¢çš„ä¸€ä¸ªhandlerä¼ é€’ä¸€ä¸ªå¯¹è±¡ï¼Ÿ
ä¸€ä¸ªç®¡é“ï¼ˆpipelineï¼‰ä¸­ä¼šæœ‰å¤šä¸ªhandler
handlerå¾€ä¸‹ä¼ é€’å¯¹è±¡çš„æ–¹æ³•æ˜¯sendUpstream(event)

æ¯ä¸ªç®¡é“ä¸‹é¢å¨¥decoderã€encoderå…¶å®æœ€ç»ˆéƒ½æ˜¯ç»§æ‰¿äº†æŸä¸ªhandler

å½“å®¢æˆ·ç«¯å‘é€æ¶ˆæ¯åˆ°æœåŠ¡ç«¯ä»¥ånettyä¼šæŠŠè¿™ä¸ªæ¶ˆæ¯å¯¹è±¡å°è£…æˆä¸€ä¸ªäº‹ä»¶ï¼ŒæŠŠäº‹ä»¶ä¼ é€’åˆ°ç®¡é“é‡Œé¢ï¼Œç®¡é“é‡Œé¢æœ‰å¾ˆå¤šhandler,æ¯æ¬¡ç»è¿‡ä¸€ä¸ªhandlerï¼Œå°±ä¼šå‡ºç°ä¸€ä¸ªæ–°çš„äº‹ä»¶ï¼Œç„¶åç»è¿‡ä¸‹ä¸€ä¸ªhandlerï¼Œå½¢æˆæ–°çš„äº‹ä»¶ã€‚
ä¹Ÿæ²¡æ‰¾åˆ°ä»€ä¹ˆå¥½çš„å›¾è§£ï¼Œæ„Ÿè°¢ï¼šhttps://www.cnblogs.com/chenmo-xpw/p/3938284.html
![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdGFpeWFuZ3U=,size_16,color_FFFFFF,t_70-20190312195850713.png)
ä¸Šå›¾ä¸­å…¶å®æ˜¯å°†ä¸€ä¸ªchannelEventå³äº‹ä»¶ä¼ å…¥äº†channelä¸­çš„pipelineï¼Œä¸‹é¢æºç ä¸­è¯¦ç»†ä»‹ç»ã€‚

## æºç è§£æ
è¿›å…¥
### AbstractNioSelector.java

```js
run(){
		...
	    process(selector);
		...
}
```
ä»processæ–¹æ³•åˆ°
### AbstractNioWorker.java

```js
process(){
	...
	if (!read(k)) {
	}
	...
}
```
ä»readæ–¹æ³•åˆ°
### NioWorker.java

```js
read(k){
	//é€šè¿‡kå¾—åˆ°channel
	final SocketChannel ch = (SocketChannel) k.channel();
	final NioSocketChannel channel = (NioSocketChannel) k.attachment();

	...
	final ChannelBuffer buffer = bufferFactory.getBuffer(readBytes);
    buffer.setBytes(0, bb);
    ...
    // Fire the event.
    fireMessageReceived(channel, buffer);
}
```
ä»fireMessageReceivedæ–¹æ³•å†è¿›å…¥fireMessageReceivedæ–¹æ³•

```js
 public static void fireMessageReceived(Channel channel, Object message, SocketAddress remoteAddress) {
 //ä»channelä¸­è·å–ä¸€ä¸ªç®¡é“ï¼Œå¾€ç®¡é“ä¸­å‘é€äº†ä¸€ä¸ªsendUpstreamäº‹ä»¶
        channel.getPipeline().sendUpstream(
        //newäº†ä¸€ä¸ªUpstreamMessageEventå¾€ç®¡é“ä¸­æ‰”
                new UpstreamMessageEvent(channel, message, remoteAddress));
    }
//ä¸Šä¼ çš„event
  public void sendUpstream(ChannelEvent e) {
  //é¦–å…ˆè·å–åˆ°ä¸€ä¸ªDefaultChannelHandlerContext,åœ¨ä¸‹é¢
  //headæ˜¯å¤´æŒ‡é’ˆ
  //getActualUpstreamContextæ–¹æ³•åœ¨ä¸‹é¢çš„DefualtChannelPipeline.java
        DefaultChannelHandlerContext head = getActualUpstreamContext(this.head);
        if (head == null) {
            if (logger.isWarnEnabled()) {
                logger.warn(
                        "The pipeline contains no upstream handlers; discarding: " + e);
            }

            return;
        }
//æ¥ç€headé‡Œé¢æ¥ç€send
//å…·ä½“å®ç°åœ¨DefaultChannelPipeline.java
        sendUpstream(head, e);
    }
```
### DefaultChannelHandlerContext.java
```js
private final class DefaultChannelHandlerContext implements ChannelHandlerContext {
		//æœ‰nextå’Œprevæ¥ç»´æŠ¤é“¾è¡¨çš„å…³ç³»ã€‚
        volatile DefaultChannelHandlerContext next;
        volatile DefaultChannelHandlerContext prev;
        private final String name;
        //å°±æ˜¯å‰é¢çš„demoä¸­çš„encodehandlerå’Œdecodehandler
        private final ChannelHandler handler;
        private final boolean canHandleUpstream;
        private final boolean canHandleDownstream;
        private volatile Object attachment;
....
}
```
å®é™…ä¸Šå°±æ˜¯é€šè¿‡ChannelHandlerContextå°è£…handlerå¯¹è±¡ï¼Œè®©handlerå’Œhandlerä¹‹é—´æœ‰ä¸€ä¸ªåŒå‘é“¾è¡¨çš„å…³ç³»
### DefualtChannelPipeline.java

```js
private DefaultChannelHandlerContext getActualUpstreamContext(DefaultChannelHandlerContext ctx) {
        if (ctx == null) {
            return null;
        }

        DefaultChannelHandlerContext realCtx = ctx;
        //åˆ¤æ–­å¤´æŒ‡é’ˆæ˜¯ä¸æ˜¯ä¸€ä¸ªå¯ä»¥æ¥å—Upstreamçš„handler
        while (!realCtx.canHandleUpstream()) {
        //ä¸æ˜¯çš„è¯å°±å¾€ä¸‹æ‰¾ï¼Œæ‰¾ä¸‹ä¸€ä¸ªå¯ä»¥æ¥å—Upstreamçš„handler
            realCtx = realCtx.next;
            if (realCtx == null) {
                return null;
            }
        }

        return realCtx;
    }



    void sendUpstream(DefaultChannelHandlerContext ctx, ChannelEvent e) {
        try {
        //ä»headé‡Œé¢å¾—åˆ°è¿™äº›handlerï¼Œç„¶åè°ƒç”¨è¿™äº›handlerçš„handleUpstreamæ–¹æ³•
        //è¿™ä¸ªæ–¹æ³•æ˜¯æŠ½è±¡æ–¹æ³•ï¼Œå½“å‰çš„ç±»ç»§æ‰¿è‡ªSimpleChannelUpstreamHandlerç±»ï¼Œæ‰€ä»¥å»è¿™ä¸ªç±»ä¸­çœ‹å…·ä½“å®ç°
        //SimpleChannelUpstreamHandleråœ¨ä¸‹é¢
            ((ChannelUpstreamHandler) ctx.getHandler()).handleUpstream(ctx, e);
        } catch (Throwable t) {
            notifyHandlerException(e, t);
        }
    }
```
æˆ‘ä»¬demoä¸­çš„StringDecoderå’ŒHellohandleræ˜¯å¯ä»¥æ¥å—Upstreamçš„ï¼Œä½†æ˜¯StringEncoderæ˜¯ä¸è¡Œçš„ï¼Œå› ä¸ºimplements ChannelDownstreamHandlerï¼Œæ˜¯ä¸€ä¸ªä¸‹è¡Œçš„handler
### SimpleChannelUpstreamHandler.java
```js
public void handleUpstream(
            ChannelHandlerContext ctx, ChannelEvent e) throws Exception {
		
        if (e instanceof MessageEvent) {
        //å¦‚æœæ˜¯MessageEventï¼Œå°±æ‰§è¡ŒmessageReceivedæ–¹æ³•
        //public void messageReceived(
        //    ChannelHandlerContext ctx, MessageEvent e) throws Exception {
        //è°ƒç”¨å®Œäº†ä¹‹åæ¥ç€è°ƒç”¨	sendUpstreamæ–¹æ³•
        // ctx.sendUpstream(e);
   		 //}	
   		 //public void sendUpstream(ChannelEvent e) {
          //  DefaultChannelHandlerContext next = getActualUpstreamContext(this.next);
         //   if (next != null) {
         //ä»å½“å‰èŠ‚ç‚¹å¾€ä¸‹æ‰¾ä¸‹ä¸€ä¸ªå¯ä»¥å¤„ç†sendUpstreamçš„handlerï¼Œç»§ç»­ä¼ é€’eäº‹ä»¶
         //       DefaultChannelPipeline.this.sendUpstream(next, e);
          //  }
       	//	 }
            messageReceived(ctx, (MessageEvent) e);
        } else if (e instanceof WriteCompletionEvent) {
            WriteCompletionEvent evt = (WriteCompletionEvent) e;
            writeComplete(ctx, evt);
        } else if (e instanceof ChildChannelStateEvent) {
            ChildChannelStateEvent evt = (ChildChannelStateEvent) e;
            if (evt.getChildChannel().isOpen()) {
                childChannelOpen(ctx, evt);
            } else {
                childChannelClosed(ctx, evt);
            }
        } else if (e instanceof ChannelStateEvent) {
            ChannelStateEvent evt = (ChannelStateEvent) e;
            switch (evt.getState()) {
            case OPEN:
                if (Boolean.TRUE.equals(evt.getValue())) {
                    channelOpen(ctx, evt);
                } else {
                    channelClosed(ctx, evt);
                }
                break;
          ....
    }

```
 é€šè¿‡ä¸Šé¢è¿™æ®µä»£ç çŸ¥é“
 **<font color="red">  handlerå¾€ä¸‹ä¼ é€’çš„ä¸€ä¸ªæ–¹æ³•æ˜¯ sendUpstream ï¼Œåº”è¯¥ç»§æ‰¿SimpleChannelUpstreamHandler</font>**
## éªŒè¯
éªŒè¯ä¸Šé¢çš„ handlerå¾€ä¸‹ä¼ é€’çš„ä¸€ä¸ªæ–¹æ³•æ˜¯ sendUpstream
 **<font color="red"> è‡ªå·±å®šä¹‰handlerã€‚
   </font>**

### Server.java

```js
package com.server;

import java.net.InetSocketAddress;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import org.jboss.netty.bootstrap.ServerBootstrap;
import org.jboss.netty.channel.ChannelPipeline;
import org.jboss.netty.channel.ChannelPipelineFactory;
import org.jboss.netty.channel.Channels;
import org.jboss.netty.channel.socket.nio.NioServerSocketChannelFactory;
import org.jboss.netty.handler.codec.string.StringDecoder;
import org.jboss.netty.handler.codec.string.StringEncoder;

public class Server {

	public static void main(String[] args) {
		//æœåŠ¡ç±»
		ServerBootstrap bootstrap = new ServerBootstrap();
		
		//bossçº¿ç¨‹ç›‘å¬ç«¯å£ï¼Œworkerçº¿ç¨‹è´Ÿè´£æ•°æ®è¯»å†™
		ExecutorService boss = Executors.newCachedThreadPool();
		ExecutorService worker = Executors.newCachedThreadPool();
		
		//è®¾ç½®niosocketå·¥å‚
		bootstrap.setFactory(new NioServerSocketChannelFactory(boss, worker));
		
		//è®¾ç½®ç®¡é“çš„å·¥å‚
		bootstrap.setPipelineFactory(new ChannelPipelineFactory() {
			
			@Override
			public ChannelPipeline getPipeline() throws Exception {

				ChannelPipeline pipeline = Channels.pipeline();
				pipeline.addLast("handler1", new MyHandler1());
				pipeline.addLast("handler2", new MyHandler2());
				return pipeline;
			}
		});
		
		bootstrap.bind(new InetSocketAddress(10101));
		
		System.out.println("start!!!");
	}

}

```
### Handler1.java

```js
package com.server;

import org.jboss.netty.buffer.ChannelBuffer;
import org.jboss.netty.channel.ChannelHandlerContext;
import org.jboss.netty.channel.MessageEvent;
import org.jboss.netty.channel.SimpleChannelHandler;
import org.jboss.netty.channel.UpstreamMessageEvent;

public class MyHandler1 extends SimpleChannelHandler {

	@Override
	public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {

		ChannelBuffer buffer = (ChannelBuffer)e.getMessage();
		
		byte[] array = buffer.array();
		String message = new String(array);
		System.out.println("handler1:" + message);
		
		//ä¼ é€’
		ctx.sendUpstream(new UpstreamMessageEvent(ctx.getChannel(), "abc", e.getRemoteAddress()));
		ctx.sendUpstream(new UpstreamMessageEvent(ctx.getChannel(), "efg", e.getRemoteAddress()));
	}
}

```
### Handler2.java

```js
package com.server;

import org.jboss.netty.channel.ChannelHandlerContext;
import org.jboss.netty.channel.MessageEvent;
import org.jboss.netty.channel.SimpleChannelHandler;

public class MyHandler2 extends SimpleChannelHandler {

	@Override
	public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {

		String message = (String)e.getMessage();
		
		System.out.println("handler2:" + message);
	}
}

```
### Client.java

```js
package com.server;

import java.net.Socket;

public class Client {

	public static void main(String[] args) throws Exception {

		Socket socket = new Socket("127.0.0.1", 10101);
		
		socket.getOutputStream().write("hello".getBytes());
		
		socket.close();
	}

}

```
### è¾“å‡º

```js
startï¼ï¼ï¼
handler1ï¼šhello
handler2ï¼šabc
handler2ï¼šefg
```
æ³¨æ„handler1ä¸­ï¼Œé€šè¿‡å¦‚ä¸‹ä»£ç å‘ä¸‹ä¼ é€’

```js
//ä¼ é€’
		ctx.sendUpstream(new UpstreamMessageEvent(ctx.getChannel(), "abc", e.getRemoteAddress()));
		ctx.sendUpstream(new UpstreamMessageEvent(ctx.getChannel(), "efg", e.getRemoteAddress()));
```
# è§‚å¯Ÿç²˜åŒ…ã€åˆ†åŒ…ç°è±¡ï¼Œå¹¶è¿›è¡Œå¤„ç†ã€‚
ç²˜åŒ…å°±æ˜¯å®¢æˆ·ç«¯åˆ†åæ¬¡è¿›è¡Œä¼ é€’åä¸ªhelloï¼Œå¯æ˜¯å®¢æˆ·ç«¯ä¸€æ¬¡å°±è¾“å‡ºäº†ï¼Œæ‰€ä»¥ä¸èƒ½åˆ¤æ–­æ˜¯å‡ æ¬¡è¯·æ±‚ï¼Œç›¸å½“äºåªå¤„ç†äº†ä¸€æ¬¡
## ä¸¾ä¸ªğŸŒ°
### Server.java

```js
package com.server;

import java.net.InetSocketAddress;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import org.jboss.netty.bootstrap.ServerBootstrap;
import org.jboss.netty.channel.ChannelPipeline;
import org.jboss.netty.channel.ChannelPipelineFactory;
import org.jboss.netty.channel.Channels;
import org.jboss.netty.channel.socket.nio.NioServerSocketChannelFactory;
import org.jboss.netty.handler.codec.string.StringDecoder;
import org.jboss.netty.handler.codec.string.StringEncoder;

public class Server {

	public static void main(String[] args) {
		//æœåŠ¡ç±»
		ServerBootstrap bootstrap = new ServerBootstrap();
		
		//bossçº¿ç¨‹ç›‘å¬ç«¯å£ï¼Œworkerçº¿ç¨‹è´Ÿè´£æ•°æ®è¯»å†™
		ExecutorService boss = Executors.newCachedThreadPool();
		ExecutorService worker = Executors.newCachedThreadPool();
		
		//è®¾ç½®niosocketå·¥å‚
		bootstrap.setFactory(new NioServerSocketChannelFactory(boss, worker));
		
		//è®¾ç½®ç®¡é“çš„å·¥å‚
		bootstrap.setPipelineFactory(new ChannelPipelineFactory() {
			
			@Override
			public ChannelPipeline getPipeline() throws Exception {

				ChannelPipeline pipeline = Channels.pipeline();
				//pipeline.addLast("decoder", new MyDecoder());
				pipeline.addLast("handler1", new HelloHandler());
				return pipeline;
			}
		});
		
		bootstrap.bind(new InetSocketAddress(10101));
		
		System.out.println("start!!!");
	}

}

```
### HelloHandler.java

```js
package com.server;

import org.jboss.netty.channel.ChannelHandlerContext;
import org.jboss.netty.channel.MessageEvent;
import org.jboss.netty.channel.SimpleChannelHandler;

public class HelloHandler extends SimpleChannelHandler {
	
	@Override
	public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {
		
		ChannelBuffer message = (ChannelBuffer)e.getMessage();
		byte[] array = message.arrage();
		System.out.println(new String (array))
	}
}

```


### Client.java

```js
package com.server;

import java.net.Socket;
import java.nio.ByteBuffer;

public class Client {

	public static void main(String[] args) throws Exception {
		Socket socket = new Socket("127.0.0.1", 10101);
		
		String message = "hello";
		
		byte[] bytes = message.getBytes();
		
		//ByteBuffer buffer = ByteBuffer.allocate(4 + bytes.length);
		//buffer.putInt(bytes.length);
		//buffer.put(bytes);
		
	//	byte[] array = buffer.array();
			
	//	for(int i=0; i<1000; i++){
	//		socket.getOutputStream().write(array);
	//	}
	for(int i=0; i<1000; i++){
			socket.getOutputStream().write(message);
		}
			
		socket.close();
	}

}

```
### è¾“å‡º

```js
start!!!
hellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohell
ohellohellohellohellohellohellohellohellohellohellohellohe
llohellohellohellohellohellohellohello
hellohellohellohellohello
```
å¦‚å›¾å°†å¾ˆå¤šè¯·æ±‚å½“åšä¸€æ¬¡è¯·æ±‚è¾“å‡ºï¼Œå°±æ˜¯ç²˜åŒ…ï¼Œåé¢å‡ è¡Œçš„è¡Œé¦–ä¸æ˜¯heå¼€å¤´çš„ï¼Œå°±æ˜¯è€Œæ˜¯ä¸Šä¸€è¡Œçš„è¡Œå°¾å’Œæœ¬è¡Œè¡Œé¦–åˆ†å¼€äº†ï¼Œå°±æ˜¯åˆ†åŒ…
## è§£å†³
å®šä¹‰ä¸€ä¸ªç¨³å®šçš„ç»“æ„ length + hello
### MyDecoder.java

```js
package com.server;

import org.jboss.netty.buffer.ChannelBuffer;
import org.jboss.netty.channel.Channel;
import org.jboss.netty.channel.ChannelHandlerContext;
import org.jboss.netty.handler.codec.frame.FrameDecoder;

public class MyDecoder extends FrameDecoder {

	@Override
	protected Object decode(ChannelHandlerContext ctx, Channel channel, ChannelBuffer buffer) throws Exception {

		if(buffer.readableBytes() > 4){
			
			//è¿™æ®µä»£ç æ˜¯ä¸ºäº†é˜²æ­¢å­—èŠ‚æµæ”»å‡»ï¼Œæœ¬æ–‡çš„ä¸‹é¢å°èŠ‚ä¸­ä¼šè®²åˆ°
			if(buffer.readableBytes() > 2048){
				buffer.skipBytes(buffer.readableBytes());
			}
			
			
			//æ ‡è®°
			buffer.markReaderIndex();
			//é•¿åº¦
			int length = buffer.readInt();
			
			if(buffer.readableBytes() < length){
				buffer.resetReaderIndex();
				//ç¼“å­˜å½“å‰å‰©ä½™çš„bufferæ•°æ®ï¼Œç­‰å¾…å‰©ä¸‹æ•°æ®åŒ…åˆ°æ¥
				return null;
			}
			
			//è¯»æ•°æ®
			byte[] bytes = new byte[length];
			buffer.readBytes(bytes);
			//å¾€ä¸‹ä¼ é€’å¯¹è±¡
			return new String(bytes);
		}
		//ç¼“å­˜å½“å‰å‰©ä½™çš„bufferæ•°æ®ï¼Œç­‰å¾…å‰©ä¸‹æ•°æ®åŒ…åˆ°æ¥
		return null;
	}

}

```
#### é—®é¢˜
1ã€ä¸ºä»€ä¹ˆFrameDecoder returnçš„å¯¹è±¡å°±æ˜¯å¾€ä¸‹ä¼ é€’çš„å¯¹è±¡

2ã€bufferé‡Œé¢æ•°æ®æœªè¢«è¯»å–å®Œæ€ä¹ˆåŠï¼Ÿ    

3ã€ä¸ºä»€ä¹ˆreturn nullå°±å¯ä»¥ç¼“å­˜buffer     

ä¼šåœ¨æœ¬æ–‡ç« çš„ä¸‹é¢çš„å°èŠ‚ä¸­è§£ç­”
### HelloHandler.java
ä¸Šé¢çš„HelloHandlerä¿®æ”¹ä¸º

```js
package com.server;

import org.jboss.netty.channel.ChannelHandlerContext;
import org.jboss.netty.channel.MessageEvent;
import org.jboss.netty.channel.SimpleChannelHandler;

public class HelloHandler extends SimpleChannelHandler {
//ä¸ºäº†ç¡®å®šæ˜¯ä¸æ˜¯ä¸€æ¬¡ä¸€æ¬¡çš„è¯·æ±‚è¿‡æ¥çš„ï¼Œ
//å› ä¸ºpipelineä¸­å¤„ç†handlerçš„æ—¶é—´æ˜¯ä¸€ä¸ªå•çº¿ç¨‹çš„æ—¶é—´
//ä¸ä¼šæ¶‰åŠåˆ°å¹¶å‘ï¼Œæ‰€ä»¥ç›´æ¥ç»™ä¸€ä¸ªç§æœ‰å˜é‡å³å¯ã€‚
	
	private int count = 1;

	@Override
	public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {
		
		System.out.println(e.getMessage() + "  " +count);
		count++;
	}
}

```
### åœ¨server.javaä¸­æ·»åŠ 

```js
pipeline.addLast("decoder", new MyDecoder());
pipeline.addLast("handler1", new HelloHandler());
```
### è¾“å‡º

```js
startï¼ï¼ï¼
hello 1
hello 2
hello 3
hello 4
```
# æŸ¥çœ‹FramDecoderæºç ï¼ˆè§£å†³ä¸Šå°èŠ‚çš„ç–‘é—®ï¼‰
FramDecoder ç»§æ‰¿SimpleChannelUpstreamHandler
ä¸Šé¢æåˆ°è¿›å…¥pipelineåç¬¬ä¸€ä¸ªå¤„ç†çš„æ–¹æ³•æ˜¯messageReceivedæ–¹æ³•
## FramDecoder
```js
@Override
    public void messageReceived(
            ChannelHandlerContext ctx, MessageEvent e) throws Exception {

        Object m = e.getMessage();
        if (!(m instanceof ChannelBuffer)) {
        //åˆ¤æ–­æ˜¯ä¸æ˜¯channelbufferï¼Œä¸æ˜¯çš„è¯å°±å‘ä¸‹ä¼ é€’äº‹ä»¶
            ctx.sendUpstream(e);
            return;
        }

        ChannelBuffer input = (ChannelBuffer) m;
        if (!input.readable()) {
        //åˆ¤æ–­æœ‰æ²¡æœ‰æ•°æ®å¯è¯»ï¼Œæ²¡æœ‰çš„è¯å°±ç›´æ¥è¿”å›
            return;
        }
		//è¿™é‡Œçš„cumulationå…¶å®å°±æ˜¯ä¸€ä¸ªç¼“å­˜çš„bufferå¯¹è±¡	
		//å‡å¦‚handlerä¸­return nullä¹‹åbufferä¸­æµ·æœ‰æ•°æ®ï¼Œå°±å­˜åˆ°è¿™é‡Œé¢
		//å‡å¦‚è¯»å®Œä¹‹åï¼Œå¾€ä¸‹ä¼ é€’å¯¹è±¡ï¼Œä½†æ˜¯bufferä¸­è¿˜æœ‰æœªä¼ é€’å®Œçš„å¯¹è±¡ï¼Œä¹Ÿä¼šå°†æ•°æ®å­˜åˆ°é‡Œé¢
		//å…¶å®        protected ChannelBuffer cumulation; æœ¬èº«ä¹Ÿæ˜¯ä¸€ä¸ªchannelbuffer
        if (cumulation == null) {
            try {
                // the cumulation buffer is not created yet so just pass the input to callDecode(...) method
                //ç¬¬ä¸€æ¬¡è¿›æ¥cumulationé‡Œé¢æ²¡æœ‰ç¼“å­˜çš„æ•°æ®è¿›å…¥callDecodeå¯¹è±¡ï¼Œå¾€ä¸‹é¢çœ‹
                //ç¬¬ä¸‰ä¸ªå‚æ•°æ˜¯æˆ‘ä»¬çš„input
                //è¿™ä¸ªæ–¹æ³•å…·ä½“å®ç°å¾€ä¸‹çœ‹
                callDecode(ctx, e.getChannel(), input, e.getRemoteAddress());
            } finally {
            	//ç¼“å­˜æ•°æ®åˆ°cumulation
                updateCumulation(ctx, input);
            }
        } else {
        //Cumulationä¸­æœ‰æ•°æ®ï¼Œå°±æŠŠæ–°çš„æ•°æ®æ·»åŠ åˆ°cumulationåé¢,å…·ä½“ä»£ç å¾€ä¸‹çœ‹
            input = appendToCumulation(input);
            try {
            //å†æ¬¡è¿›å…¥callDecodeæ–¹æ³•
                callDecode(ctx, e.getChannel(), input, e.getRemoteAddress());
            } finally {
                updateCumulation(ctx, input);
            }
        }
    }


 private void callDecode(
            ChannelHandlerContext context, Channel channel,
            ChannelBuffer cumulation, SocketAddress remoteAddress) throws Exception {

        while (cumulation.readable()) {
        //é¦–å…ˆè®°å½•ä¸€ä¸‹è¯»æŒ‡é’ˆä½ç½®
            int oldReaderIndex = cumulation.readerIndex();
            //ç„¶åæ‰§è¡Œdecodeæ–¹æ³•ï¼Œè¿™é‡Œçš„decodeæ–¹æ³•å°±æ˜¯æˆ‘æˆ‘ä»¬ä¹‹å‰è‡ªå®šä¹‰çš„myDecoderç­‰æ–¹æ³•
            //å›ä¸€ä¸‹ä¹‹å‰è‡ªå®šä¹‰çš„ï¼Œå¦‚æœè¿›æ¥çš„æ•°æ®å°äºå››ä¸ªå­—èŠ‚ï¼Œç›´æ¥return nullï¼Œå¦‚æœé•¿åº¦ä¸å¤Ÿä¹Ÿreturn null
            //åˆ¤æ–­é•¿åº¦ä¹‹åï¼Œè¯»ï¼Œè¯»å®Œä¹‹åbufferä¸­è¿˜æœ‰æ•°æ®ï¼Œreturn new Stringï¼ˆï¼‰ï¼›
            //çœ‹ä¸€ä¸‹è¿™é‡Œrenturnçš„å¯¹è±¡æ˜¯frame
            Object frame = decode(context, channel, cumulation);
            if (frame == null) {
            //é¦–å…ˆçœ‹æ—§çš„æŒ‡é’ˆå’Œç°åœ¨çš„æ˜¯ä¸æ˜¯ä¸€æ ·
                if (oldReaderIndex == cumulation.readerIndex()) {
                    // Seems like more data is required.
                    // Let us wait for the next notification.
                    //æ˜¯çš„è¯å°±ä¸ç®¡äº†
                    //ç¬¬ä¸€æ¬¡returnäº†è¿”å›çœ‹ä¸Šé¢çš„ä»£ç 
                    break;
                } else {
                    // Previous data has been discarded.
                    // Probably it is reading on.
                    continue;
                }
            }
            //å¦‚æœæˆ‘ä»¬è‡ªå®šä¹‰çš„Handlerä¸æ˜¯return nullï¼Œå°±èµ°è¿™é‡Œ
            //å¦‚æœæ—§çš„æŒ‡é’ˆå’Œæ–°çš„æŒ‡é’ˆç›¸åŒçš„è¯ï¼Œå°±ä¼šæŠ›å‡ºå¼‚å¸¸
            //å¯æ˜¯æˆ‘ä»¬returnçš„æ˜¯ä¸€ä¸ªstringï¼Œæ‰€ä»¥è‚¯å®šä¸æ˜¯null
            if (oldReaderIndex == cumulation.readerIndex()) {
                throw new IllegalStateException(
                        "decode() method must read at least one byte " +
                        "if it returned a frame (caused by: " + getClass() + ')');
            }
			//æ‰€ä»¥èµ°åˆ°äº†è¿™é‡Œï¼Œå…·ä½“ä»£ç å¾€ä¸‹çœ‹
            unfoldAndFireMessageReceived(context, remoteAddress, frame);
        }
    }
    //å°±æ˜¯çœ‹inputé‡Œé¢è¿˜æœ‰æ²¡æœ‰æ•°æ®ï¼Œæœ‰çš„è¯å°±æŠŠæ•°æ®åŠ åˆ°cumulationä¸­
protected ChannelBuffer updateCumulation(ChannelHandlerContext ctx, ChannelBuffer input) {
        ChannelBuffer newCumulation;
        int readableBytes = input.readableBytes();
        if (readableBytes > 0) {
            int inputCapacity = input.capacity();

            // If input.readableBytes() == input.capacity() (i.e. input is full),
            // there's nothing to save from creating a new cumulation buffer
            // even if input.capacity() exceeds the threshold, because the new cumulation
            // buffer will have the same capacity and content with input.
            if (readableBytes < inputCapacity && inputCapacity > copyThreshold) {
                // At least one byte was consumed by callDecode() and input.capacity()
                // exceeded the threshold.
                cumulation = newCumulation = newCumulationBuffer(ctx, input.readableBytes());
                cumulation.writeBytes(input);
            } else {
                // Nothing was consumed by callDecode() or input.capacity() did not
                // exceed the threshold.
                if (input.readerIndex() != 0) {
                    cumulation = newCumulation = input.slice();
                } else {
                    cumulation = newCumulation = input;
                }
            }
        } else {
            cumulation = newCumulation = null;
        }
        return newCumulation;
    }
    //å¦‚è¿‡cumulationä¸­æœ‰æ•°æ®ï¼Œå°±æŠŠæ–°çš„æ•°æ®åŠ åˆ°åé¢ï¼Œè¿”å›ä¸Šé¢æ¥ç€çœ‹
 protected ChannelBuffer appendToCumulation(ChannelBuffer input) {
        ChannelBuffer cumulation = this.cumulation;
        assert cumulation.readable();
        if (cumulation instanceof CompositeChannelBuffer) {
            // Make sure the resulting cumulation buffer has no more than the configured components.
            CompositeChannelBuffer composite = (CompositeChannelBuffer) cumulation;
            if (composite.numComponents() >= maxCumulationBufferComponents) {
                cumulation = composite.copy();
            }
        }

        this.cumulation = input = ChannelBuffers.wrappedBuffer(cumulation, input);
        return input;
    }

 protected final void unfoldAndFireMessageReceived(
            ChannelHandlerContext context, SocketAddress remoteAddress, Object result) {
        if (unfold) {
        	//resultå°±æ˜¯æˆ‘ä»¬ä¸Šé¢çš„frameï¼Œå°±æ˜¯è‡ªå®šä¹‰çš„handlerä¸­çš„return åé¢çš„å€¼ï¼ˆèµ°åˆ°è¿™æ­¥è¯´æ˜returnè‚¯å®šä¸æ˜¯nullï¼‰
        	//å¦‚æœæ˜¯æ•°ç»„
            if (result instanceof Object[]) {
                for (Object r: (Object[]) result) {
                    Channels.fireMessageReceived(context, r, remoteAddress);
                }
            } else if (result instanceof Iterable<?>) {
                for (Object r: (Iterable<?>) result) {
                    Channels.fireMessageReceived(context, r, remoteAddress);
                }
            } else {
            //fireMessageReceivedæ–¹æ³•å¾€ä¸‹çœ‹ï¼Œå…¶å®è¿˜æ˜¯æ‰§è¡Œäº†sendUpStreamæ–¹æ³•ï¼Œä¹Ÿå°±æ˜¯å¾€ä¸‹ä¼ ã€‚
                Channels.fireMessageReceived(context, result, remoteAddress);
            }
        } else {
            Channels.fireMessageReceived(context, result, remoteAddress);
        }
    }

public static void fireMessageReceived(
            ChannelHandlerContext ctx, Object message, SocketAddress remoteAddress) {
        ctx.sendUpstream(new UpstreamMessageEvent(
                ctx.getChannel(), message, remoteAddress));
    }
```
## ç­”æ¡ˆ
1ã€ä¸ºä»€ä¹ˆFrameDecoder returnçš„å¯¹è±¡å°±æ˜¯å¾€ä¸‹ä¼ é€’çš„å¯¹è±¡  ï¼ˆè¿˜æ˜¯è°ƒç”¨äº†sendUpstreamï¼‰

2ã€bufferé‡Œé¢æ•°æ®æœªè¢«è¯»å–å®Œæ€ä¹ˆåŠï¼Ÿ    ï¼ˆcumulationç¼“å­˜ï¼‰

3ã€ä¸ºä»€ä¹ˆreturn nullå°±å¯ä»¥ç¼“å­˜buffer     ï¼ˆcumulationç¼“å­˜ï¼‰

# å¦‚ä½•é¿å…socketæ”»å‡» 
ä¸Šé¢çš„é•¿åº¦åŠ å†…å®¹çš„æ–¹å¼è¿˜æ˜¯æœ‰é—®é¢˜çš„
æ¯”å¦‚å®¢æˆ·ç«¯å‘é€çš„æ•°æ® é•¿åº¦æ˜¯8ï¼Œå¯æ˜¯çœŸæ­£å‘é€äº†10ä¸ªå­—èŠ‚ã€‚
æˆ–è€…å®¢æˆ·ç«¯å‘é€äº†Integer.Maxä¸ªå­—èŠ‚ï¼Œæ¯æ¬¡åˆ¤æ–­

```js
if(buffer.readableBytes() < length){
				buffer.resetReaderIndex();
				//ç¼“å­˜å½“å‰å‰©ä½™çš„bufferæ•°æ®ï¼Œç­‰å¾…å‰©ä¸‹æ•°æ®åŒ…åˆ°æ¥
				return null;
}
```
æ¯æ¬¡éƒ½æ˜¯åˆ¤æ–­ï¼Œä¸æ–­çš„ç½‘ç¼“å­˜é‡Œé¢ç”Ÿäº§æ•°æ®åŒ…ï¼ŒçŸ¥é“å†…å­˜ä¸å¤Ÿï¼Œå®•æœº

æŠŠé•¿åº¦å®šä¹‰çš„å¾ˆå¤§ï¼Œè¿™ç§æ•°æ®åŒ…ï¼Œé€šå¸¸è¢«ç§°ä¸ºsocketæ”»å‡»ï¼Œå­—èŠ‚æµå¼æ”»å‡»

## è§£å†³ï¼ˆğŸŒ°ï¼‰
å¯ä»¥é€šè¿‡æ¸…é™¤ç¼“å­˜çš„æ–¹å¼ï¼Œå¯æ˜¯å› ä¸ºæ¸…é™¤äº†æ•°æ®ä¹‹åï¼Œå› ä¸ºå¯èƒ½ä¼šå‡ºç°åˆ†åŒ…æˆªæ–­çš„ç°è±¡ï¼Œä¸‹æ¬¡è¿›æ¥çš„æ—¶å€™ï¼Œå¯èƒ½ä¸æ˜¯å¼€å¤´ï¼Œæ‰€ä»¥ä¸èƒ½çŸ¥é“å“ªä¸ªæ˜¯é•¿åº¦ï¼Œå“ªä¸ªæ˜¯æ•°æ®ï¼Œæ‰€ä»¥éœ€è¦åŒ…å¤´ï¼Œåªæœ‰å½“æ—¶è¯»åˆ°åŒ…å¤´çš„æ—¶å€™æ‰ç»§ç»­å¾€ä¸‹èµ°ã€‚
### ResponseDecoder.java

```js
package com.cn.codc;

import org.jboss.netty.buffer.ChannelBuffer;
import org.jboss.netty.channel.Channel;
import org.jboss.netty.channel.ChannelHandlerContext;
import org.jboss.netty.handler.codec.frame.FrameDecoder;
import com.cn.constant.ConstantValue;
import com.cn.model.Response;

/**
 * responseè§£ç å™¨
 * <pre>
 * æ•°æ®åŒ…æ ¼å¼
 * +â€”â€”----â€”â€”+â€”â€”-----â€”â€”+â€”â€”----â€”â€”+â€”â€”----â€”â€”+â€”â€”-----â€”â€”+â€”â€”-----â€”â€”+
 * | åŒ…å¤´          | æ¨¡å—å·        | å‘½ä»¤å·       |  çŠ¶æ€ç     |  é•¿åº¦          |   æ•°æ®       |
 * +â€”â€”----â€”â€”+â€”â€”-----â€”â€”+â€”â€”----â€”â€”+â€”â€”----â€”â€”+â€”â€”-----â€”â€”+â€”â€”-----â€”â€”+
 * </pre>
 * åŒ…å¤´4å­—èŠ‚
 * æ¨¡å—å·2å­—èŠ‚short
 * å‘½ä»¤å·2å­—èŠ‚short
 * é•¿åº¦4å­—èŠ‚(æè¿°æ•°æ®éƒ¨åˆ†å­—èŠ‚é•¿åº¦)
 * 
 -
 *
 */
public class ResponseDecoder extends FrameDecoder{
	
	/**
	 * æ•°æ®åŒ…åŸºæœ¬é•¿åº¦
	 */
	public static int BASE_LENTH = 4 + 2 + 2 + 4;

	@Override
	protected Object decode(ChannelHandlerContext arg0, Channel arg1, ChannelBuffer buffer) throws Exception {
		
		//å¯è¯»é•¿åº¦å¿…é¡»å¤§äºåŸºæœ¬é•¿åº¦
		if(buffer.readableBytes() >= BASE_LENTH){
			//é˜²æ­¢å­—èŠ‚æµæ”»å‡»
			if(buffer.readableBytes()>2048){
			//æ¸…é™¤ç¼“å­˜ä¸­çš„æ•°æ®
				buffer.skipBytes(buffer.readableBytes());
			}
			//è®°å½•åŒ…å¤´å¼€å§‹çš„index
			int beginReader ï¼›
			
			while(true){
				beginReader = buffer.readerIndex();
				//æ ‡è®°å½“å‰ç´¢å¼•
				buffer.markReaderIndex();
				//åˆ¤æ–­åŒ…å¤´æ˜¯å¦æ˜¯å½“å‰çš„åŒ…å¤´
				//å› ä¸ºæ¸…é™¤äº†æ•°æ®ä¹‹åï¼Œå› ä¸ºå¯èƒ½ä¼šå‡ºç°åˆ†åŒ…æˆªæ–­çš„ç°è±¡ï¼Œä¸‹æ¬¡è¿›æ¥çš„æ—¶å€™ï¼Œ
				//å¯èƒ½ä¸æ˜¯å¼€å¤´ï¼Œæ‰€ä»¥ä¸èƒ½çŸ¥é“å“ªä¸ªæ˜¯é•¿åº¦ï¼Œå“ªä¸ªæ˜¯æ•°æ®ï¼Œæ‰€ä»¥éœ€è¦åŒ…å¤´ï¼Œ
				//åªæœ‰å½“æ—¶è¯»åˆ°åŒ…å¤´çš„æ—¶å€™æ‰ç»§ç»­å¾€ä¸‹èµ°ã€‚
				if(buffer.readInt() == ConstantValue.FLAG){
					break;
				}
				//æœªè¯»åˆ°åŒ…å¤´è¶…è¿‡äº†ä¸€ä¸ªå­—èŠ‚
				buffer.resetReaderIndex();
				//å› ä¸ºå¯èƒ½è¯»ä¸€ä¸ªintä¹‹åï¼Œç•¥è¿‡äº†åŒ…å¤´ï¼Œå› ä¸ºå¯èƒ½åŒ…å¤´åœ¨ç¬¬ä¸€ä¸ªå­—èŠ‚å¤„
				//æ‰€ä»¥è¿™é‡Œé€‰æ‹©ç»§ç»­å¾€ä¸‹è¯»ä¸€ä¸ªå­—èŠ‚
				buffer.readByte();
				//å¯èƒ½å‡ºç°æç«¯çš„æƒ…å†µï¼Œé•¿åº¦åˆå˜å¾—ä¸æ»¡è¶³
				if(buffer.readableBytes()<BASE_LENGTH){
					return null
				}
			}
			
			//æ¨¡å—å·
			short module = buffer.readShort();
			//å‘½ä»¤å·
			short cmd = buffer.readShort();
			//çŠ¶æ€ç 
			int stateCode = buffer.readInt();
			//é•¿åº¦
			int length = buffer.readInt();
			
			if(buffer.readableBytes() < length){
				//è¿˜åŸè¯»æŒ‡é’ˆ
				buffer.readerIndex(beginReader);
				return null;
			}
			
			byte[] data = new byte[length];
			buffer.readBytes(data);
			
			Response response = new Response();
			response.setModule(module);
			response.setCmd(cmd);
			response.setStateCode(stateCode);
			response.setData(data);
			
			//ç»§ç»­å¾€ä¸‹ä¼ é€’ 
			return response;
			
		}
		//æ•°æ®åŒ…ä¸å®Œæ•´ï¼Œéœ€è¦ç­‰å¾…åé¢çš„åŒ…æ¥
		return null;
	}

}
```